<?xml version='1.0'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
                  "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [

<!ENTITY Evolution "<application>Evolution</application>">
<!ENTITY GNOME "<application>GNOME</application>">
<!ENTITY eclipse "<application>Eclipse</application>">
<!ENTITY Camel "<application>Camel</application>">
<!ENTITY EPlugin "<application>EPlugin</application>">
<!ENTITY e-popup-reference SYSTEM "e-popup.xml">
<!ENTITY e-menu-reference SYSTEM "e-menu.xml">
<!ENTITY e-config-reference SYSTEM "e-config.xml">
<!ENTITY e-event-reference SYSTEM "e-event.xml">
<!ENTITY e-plugin-reference SYSTEM "e-plugin.xml">

<!ENTITY em-popup-reference SYSTEM "em-popup.xml">

]>
<?xml-stylesheet href="sdocbook.css" type="text/css"?>

<book lang="en">
  <!-- DocBook file was created by LyX 1.3
  See http://www.lyx.org/ for more information -->
  <bookinfo>
    <title>
      &Evolution; Plugin Development Manual
    </title>
    
    <authorgroup>
      <corpauthor>
	Novell, Inc.
      </corpauthor>
      <author>
	<firstname>Michael</firstname><surname>Zucchi</surname>
      </author>
    </authorgroup>

    <copyright>
      <year>2004</year>
      <holder>Novell, Inc.</holder>
    </copyright>

  </bookinfo>

  <preface id="preface">
    <title>Preface</title>

    <para>
      This document is work-in-progress.  Its structure and design is still as
      fluid as the underlying strucutre and design of some parts of EPlugin.
      There's no guarantee it will be updated at regular intervals,
      particularly this version.
    </para>
    <para>
      The API documentation is currently generated using the Linux kernel-doc
      script.  The stylesheets used to generate the HTML you're seeing seems to
      have bugs which duplicates some sections.  It is also ugly and difficult
      to navigate.
    </para>

    <sect1>
      <title>Conventions</title>
      <para>
	The following conventions are used in the manual ... (insert details
	here).
      </para>
      <sect2>
	<title>XML Annotation</title>
	<para>
	  XML definitions are annotated with BNF-style markers to indicate
	  alternative (|), multiples (* or +), and optional (?) items.  If no
	  annotation is present then the item must be present once.
	</para>
	<variablelist>
	  <varlistentry>
	    <!-- is symbol the right one here? -->
	    <term><symbol>|</symbol></term>
	    <listitem>
	      <para>Indicates an alternative option.  Only one of the items
		separated by <symbol>|</symbol> is to be chosen.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><symbol>*</symbol></term>
	    <listitem>
	      <para>Following an item, <symbol>*</symbol> indicates the item
		may occur any number of times, including no times (0 or more
		multiple).
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><symbol>+</symbol></term>
	    <listitem>
	      <para>Following an item, <symbol>+</symbol> indicates the item
		must occur at least once, but may occur more than ones (1 or
		more multiple).
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><symbol>?</symbol></term>
	    <listitem>
	      <para>Following an item, <symbol>?</symbol> indicates the item
		may occur at most once, if present (0 or 1 times).
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect2>
    </sect1>

  </preface>

  <part id="informational">
    <title>
      EPlugin
    </title>
    <chapter>
      <title>
	Introduction
      </title>
      <para>
	This book aims to be a comprehensive technical manual for the
	development of plugins for &Evolution;, a personal information manager
	for &GNOME;.
      </para>
      <para>
	Up-to, and including, &Evolution; version 2.0, &Evolution; contained
	limited extensibility interfaces. There were only two ways to extend
	&Evolution;; by implementing a new top-level component, or by
	implementing a &Camel; provider. When implementing a top-level component,
	there was still little integration, and in effect it was merely a more
	complex way of writing a separate &GNOME; application. &Camel; providers
	were only designed to be e-mail storage backends, so were of limited
	use for general extensibility. Despite this, both mechanisms were used
	for example for the Exchange Connector, although the system made the
	integration clumsy and difficult.
      </para>
      <para>
	This lack of extensibility has severaly stifled external developer
	contributions by forcing any extensions to be considered as core
	features. &Evolution; being a commercial product, it has tight usability
	and quality requirements that limits the ability to experiment with
	the core feature set in this way. As a result, very few lines of code
	or new features have been implemented by external contributors.
      </para>
      <para>
	One of the major goals for the 2.2 release was to implement an
	extensibility system, given the working name of EPlugin, which must
	provide a frame-work for both providing extensibility hooks, and for
	extending the functionality of &Evolution;.
      </para>
      <sect1>
	<title>
	  Plugin System
	</title>
	<para>
	  Any plugin system will generally have a number of goals:
	</para>
	<itemizedlist>
	  <listitem>
	    <para>
	      Provide a language independent invocation mechanism
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Allow extension of parts of the user interface and processing elements
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Require minimal extra or foreign code to implement in the core application
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Require minimal interface code to implement the extensions
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Not to impact performance or increase resource usage unduly
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Versioning
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Be able to be extended itself fairly easily.
	    </para>
	  </listitem>
	</itemizedlist>
	<para>
	  EPlugin manages to fulfill these goals in most cases. EPlugin isn't a
	  single object or interface in itself, although there is an object
	  titled EPlugin, it is a synergistic collection of integrated and
	  continually evolving objects which work together to achieve these
	  goals (and that will definitly be the end of the MarketSpeak). It
	  consists of a loader to invoke extension callbacks, hooks to resolve
	  these callbacks, targets to identify context, and managers which are
	  used by the core code to provide functionality and merging points for
	  the extensions.
	</para>
	<para>
	  EPlugin's design was inspired and influenced by the &eclipse;
	  project. It aims at a lower target however, so it was more easily
	  implemented in a practical time-frame.
	</para>
	<para>
	  The EPlugin world is awash with its own language. The next few
	  sections will introduce the basic plugin nomenclature and high-level
	  view of this world.
	</para>

      </sect1>

      <sect1>
	<title>
	  Loaders
	</title>
	<para>
	  The core of EPlugin is a light-weight object loader and callback
	  invocation system. Because of the varied calling conventions of
	  different languages, and to reduce the overhead of the plugin system
	  itself, all callbacks only receive and return a single argument. By
	  using structures to pass complex arguments, native C plugins require
	  no extra overhead, and marshalling details are moved into the plugin
	  implementation itself where required. It also simplifies memory
	  management issues significantly. For example, the C plugin handler
	  merely loads a shared library using GModule, and resolves a symbol by
	  name; and is so all of 50 lines of code, total. The loaders are the
	  only modules which need to interace with non-native code or
	  conventions.
	</para>
	<para>
	  The other task of the plugin core is to load XML definitions of the
	  plugins. Extension hooks are registered with the plugin core before
	  the plugins are scanned, and are automatically instantiated to load
	  each definition appropriately as they are encountered.
	</para>
	<para>
	  At each layer, a level of indirection is used so that new loaders and
	  new hooks can be added transparently, and extend the plugin
	  definition freely with any information they require.
	</para>
      </sect1>

      <sect1>
	<title>
	  Hooks
	</title>
	<para>
	  The hooks which are registered with the loader provide meta-data for
	  the management implementation layer for extending it at
	  run-time. Their primary
	  functions are to load the detail of the XML plugin definition, map it
	  to the implementation, and marshal the implementation callbacks to
	  the common plugin interface. How they do this depends on the
	  implementation itself, and ranges from registering factory methods to
	  simply adding the items directly.
	</para>
	<para>
	  In most cases the physical object need not be loaded until the
	  callback is invoked, since the plugin definitions provide enough
	  contextual information to build the interface or determine when they
	  need to be invoked.
	</para>
      </sect1>

      <sect1>
	<title>
	  Managers
	</title>
	<para>
	  Managers
	  <footnote>
	    <para>
	      Unlike real managers, these are the ones that do the heavy lifting.
	    </para>
	  </footnote>
	  provide tools for the core code to extend itself at specific
	  points, and in many cases are the objects used directly in the code
	  to implement core features. In other cases they simply provide the
	  hooks with an entry point into &Evolution;. For example, for the main
	  menu hook, the manager is a thin layer to BonoboUI. On the other
	  hand, EPopup is a complete implementation of a popup menu management
	  system which was already used in &Evolution; 2.0. Some managers are
	  one-off objects used as constructors for other objects, others are
	  view-dependent, and some are static objects, such as the Event
	  routers.
	</para>
      </sect1>

      <sect1>
	<title>
	  Items
	</title>
	<para>
	  Each manager uses a number of items to describe the object they
	  control or create. The items are added to each manager instance from
	  the plugins or from core code. The items from all of these sources
	  are then merged together when required and processed accordingly. For
	  example, menu items are merged into the display format. Events on the
	  other hand are simply ordered and then invoked in the order of their
	  priority. Items are part of the manager implementation, and in
	  EPlugin they are all extensible objects too, which the hooks use to
	  perform mapping to the plugin. Items may be extended by code hooking
	  into the implementation, either the plugin hooks, or the core code.
	</para>
      </sect1>

      <sect1>
	<title>
	  Targets
	</title>
	<para>
	  Targets are view or component specific context objects. They contain
	  enough information to be used as stand-alone contexts to implement
	  callbacks for both core functions and plugin hooks. For example for
	  the mail view, a select target contains a folder and a list of
	  selected messages. An attachment (part) target contains the
	  &Camel; representation of the part and the mime-type for
	  that part. Targets are part of the manager implementation and are
	  extended by subclassing the manager.
	</para>
      </sect1>
    </chapter>

    <chapter>
      <title>
	Plugin Hooks
      </title>
      <para>
	This chapter will introduce the available plugin hook types. A given
	plugin can hook into any of these hooks any number of times. Some refer
	to specific instances of objects and others are implicitly defined.
      </para>
      <para>
	By design, there is considerable similarity and orthogonality amongst
	all of the various hook types and management objects.
      </para>
      <sect1>
	<title>
	  Popup Menus
	</title>
	<para>
	  The popup menu hook lets you hook into any of the context menus in
	  &Evolution;, by name and context. Complex, dynamic, and multi-level
	  menus are created on the fly by merging the items for a given menu as
	  it is being shown. Each component provides its own context targets to
	  self-describe the situation under which the menu is invoked. Plugins
	  and core code alike are then invoked at the user's direction. The
	  popup manager and all context data lives as long as the menu and
	  until a choice is made, simplifying memory management.
	</para>
	<para>
	  The menu is merged from multiple plugins and core application code by
	  using a simple lexiographical sort of an absolute path to the menu
	  item. This merged list is then scanned and expanded into a tree of
	  menus. Individual items can be hidden or inactive based on the target
	  and a simple mask which is defined by the component itself. A rich
	  collection of menu item types are possible, from simple, to
	  checkboxes or images. The popup code is simple, and easy to use, and
	  simplifies the use of popup menu's in the core application anyway,
	  that they are pluggable is a free-bonus.
	</para>
	<sect2>
	  <title>Defining a popup hook</title>
	  <para>
	    Not sure if this fits here as such.  Probably temporary placeholder.
	  </para>
	  <programlisting>
	    <![CDATA[
<hook class="com.ximian.evolution.mail.popup:1.0">
 <menu id="menuid" target="targettype">
  <item
   type="item | toggle | radio | image | submenu | bar"
   active ?
   path="foo/bar"
   label="menu text"
   icon="icon name" ?
   visible="target mask" ?
   enable="target mask" ?
   activate="function spec"/> *
 </menu> *
</hook>]]></programlisting>
	  <!-- this is all too bloody verbose, is there a better way? -->
	  <para>
	    <emphasis>Need to define menu tag</emphasis>
	  </para>
	  <variablelist>
	    <varlistentry>
	      <term><parameter>type</parameter></term>
	      <listitem>
		<para>
		  The menu item type.  The type maps directly to the
		  corresponding EPopupItem types.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>active</parameter></term>
	      <listitem>
		<para>
		  If present, then radio or toggle menu items are active when
		  first shown.  After the first instantiation, they will
		  remember their active state.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>path</parameter></term>
	      <listitem>
		<para>
		  A '/' separated path used to position the item within menu
		  and in the right submenu.  Each menu and plugin should
		  define how its menu's are layed out so other plugins can
		  determine what value to use here.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>label</parameter></term>
	      <listitem>
		<para>
		  The text to be displayed on the menu item.  This will be
		  translated based on the plugin translation domain (FIXME:
		  domain's are not yet available).
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>icon</parameter></term>
	      <listitem>
		<para>
		  The name of a gnome-icon-theme standard icon, or the full
		  path-name of an icon image to use as menu item icon.  This
		  will be blank if not supplied.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>visible</parameter></term>
	      <listitem>
		<para>
		  A comma separated list of mask enumeration values used to
		  define when this item is shown.  What values are valid
		  depend on the menu hook class of the menu being hooked
		  onto.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>enable</parameter></term>
	      <listitem>
		<para>
		  A comma separated list of mask enumeration values used to
		  define when this item is enabled.  What values are valid
		  depend on the menu hook class of the menu being hooked
		  onto.  This is currently unimplemented.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>activate</parameter></term>
	      <listitem>
		<para>
		  A plugin-type specific function specification.  This
		  function will be resolved and called when the menu item is
		  activated.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</sect2>
      </sect1>

      <sect1>
	<title>
	  Main menus
	</title>
	<para>
	  The main menu hook lets you hook into various main menus in
	  &Evolution;, based on the current active view (component). The system
	  works by piggy-backing on the existing use of the BonoboUI menu
	  system used by all of the &Evolution; components. Bonobo handles the
	  menu merging and user input, and the hook resolves the verb being
	  invoked and redirects it to the plugin. Each view defines a single
	  target which describes the appropriate context. For the Mail view,
	  this is the current folder and currently selected message(s).
	</para>
	<para>
	  Each view keeps track of its own manager object. When it is
	  (de)activated, it also (de)activates the management object which
	  dynamically adds and removes the menu items from the
	  BonoboUIContainer via a supplied BonoboUI XML definition file
	  &lt;perhaps it should embed the bonobouixml&gt;. If the target
	  changes, the view lets the manager know, and it updates the
	  visibility and sensitivity of objects appropriately, allowing
	  reasonably dynamic user-interfaces to be managed automatically. The
	  plugin itself isn't loaded until the menu item in question is invoked
	</para>
	<para>
	  Simple menu items and toggle menu items are supported currently.
	</para>
	<sect2>
	  <title>Defining a menu hook</title>
	  <para>
	    Not sure if this fits here as such.  Probably temporary placeholder.
	  </para>
	  <programlisting>
	    <![CDATA[
<hook class="com.ximian.evolution.mail.bonoboMenu:1.0">
 <menu id="menuid" target="targettype">
  <item
   type="item | toggle | radio"
   active ?
   path="/commands/FooBar"
   verb="FooBar"
   visible="target mask" ?
   enable="target mask" ?
   activate="function spec"/> *
 </menu> *
</hook>]]></programlisting>
	  <para>
	    <emphasis>Need to define menu tag</emphasis>
	  </para>
	  <variablelist>
	    <varlistentry>
	      <term><parameter>type</parameter></term>
	      <listitem>
		<para>
		  The menu item type.  The type maps directly to the
		  corresponding EMenuItem types.
		  <parameter>radio</parameter> is currently not implemented.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>active</parameter></term>
	      <listitem>
		<para>
		  If present, then radio or toggle menu items are active when
		  first shown.  After the first instantiation, they will
		  remember their active state.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>path</parameter></term>
	      <listitem>
		<para>
		  The BonoboUI element path corresponding to this menu item.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>verb</parameter></term>
	      <listitem>
		<para>
		  The BonoboUI verb corresponding to the item to be listened to.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>visible</parameter></term>
	      <listitem>
		<para>
		  A comma separated list of mask enumeration values used to
		  define when this item is shown.  What values are valid
		  depend on the menu hook class of the menu being hooked
		  onto.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>enable</parameter></term>
	      <listitem>
		<para>
		  A comma separated list of mask enumeration values used to
		  define when this item is sensitive.  What values are valid
		  depend on the menu hook class of the menu being hooked
		  onto.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>activate</parameter></term>
	      <listitem>
		<para>
		  A plugin-type specific function specification.  This
		  function will be resolved and called when the menu item is
		  activated.  The funciton's parameters will depend on the type
		  of menu item being invoked.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</sect2>
      </sect1>

      <sect1>
	<title>
	  Configuration Pages and Wizards
	</title>
	<para>
	  Configuration pages are somewhat more complex than any of the other
	  types of hookable object. This is reflected in the complexity of the
	  items and callbacks involved.
	</para>
	<para>
	  Essentially, the EConfig object is used in combination to both
	  instrument existing windows and building new content.  Each
	  configuration window comprises of several basic elements with some
	  minor variations allowed.  It consists of a number of pages in a
	  specific order, each containing a number of titled sections in a specific
	  order, each containing a number of items.  The variations are that
	  the top-level widget may be a GtkNotebook or a GnomeDruid; and each
	  section may instrument a GtkBox, or a GtkTable.  The definition of
	  the available hooks will define what form they take.
	</para>
	<para>
	  The EConfig manager uses the description of all the items supplied to
	  it to build the complete window.  It can also drive various aspects
	  of the UI, such as navigating through a druid or handling
	  instant-apply vs. modify-and-save dialogues.
	</para>
	<figure>
	  <title>Event and Data Flow in EMConfig</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="images/e-config-flow.pic" format="PIC"/>
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="images/e-config-flow.png" format="PNG"/>
	    </imageobject>
	    <textobject>
	      <phrase>A flow of information and control signals in the
		configuration management object.</phrase>
	    </textobject>
	  </mediaobject>
	</figure>

	<sect2>
	  <title>Defining a configuration page hook</title>
	  <para>
	    Not sure if this fits here as such.  Probably temporary placeholder.
	  </para>
	  <programlisting>
	    <![CDATA[
<hook class="com.ximian.evolution.mail.bonoboMenu:1.0">
 <group
  id="window id"
  target="targettype"
  commit="function spec"?
  abort="function spec"?>
  <item
   type="book | druid | page | page_start | page_finish | section | section_table | item"
   path="/absolute/path"
   label="name" | factory="function  spec"
  /> *
 </menu> *
</hook>]]></programlisting>
	  <para>
	    <emphasis>Need to define group tag</emphasis>
	  </para>
	  <variablelist>
	    <varlistentry>
	      <term><parameter>type</parameter></term>
	      <listitem>
		<para>
		  The menu item type.  The type maps directly to the
		  corresponding EConfigItem types.  Only one of
		  <parameter>book</parameter> and <parameter>druid</parameter>
		  may be supplied for the entire configuration page, and this
		  will usually already be defined by the application.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>path</parameter></term>
	      <listitem>
		<para>
		  The path to the configuration item in question.  This is a
		  simple string that when sorted using an ASCII sort will place
		  the items in the right order.  That is, sections before items
		  before pages before the root object.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>label</parameter></term>
	      <listitem>
		<para>
		  The textual label of this item.  This may only be supplied
		  for the section and page types.  For sections it will be the
		  section frame text.  For pages this will be the druid page
		  title or the notebook tab text.  If a
		  <parameter>factory</parameter>is supplied then this value is
		  not used.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>factory</parameter></term>
	      <listitem>
		<para>
		  If supplied, the factory method used to create the GtkWidget
		  elements for this configuration item.  Factories may be
		  supplied for any of the item types.  If no
		  <parameter>label</parameter> is set then the
		  <parameter>factory</parameter> must be set.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</sect2>
      </sect1>

      <sect1>
	<title>
	  Events
	</title>
	<para>
	  No extensibility framework would be complete without an event
	  system. Events are used to reflect changes in internal state of the
	  application, and track actions by the user. They can contain any
	  information and additionally can be filtered based on the information
	  itself. Special targets are used, as in the other plugin hooks, to
	  hold this information.
	</para>
	<para>
	  Event managers are defined to contain the different event types that
	  a given component can export. Only one event manager object is
	  instantiated for each component, and each plugin listening to events
	  from that component are registered on that event manager directly.
	</para>
	<para>
	  Events handlers have priorities, and can swallow events, allowing
	  some level of complexity of event routing. This feature might not
	  prove useful and may be removed in the future if it isn't.
	</para>
	<sect2>
	  <title>Defining an event hook</title>
	  <para>
	    Not sure if this fits here as such.  Probably temporary placeholder.
	  </para>

	  <programlisting>
	    <![CDATA[
<hook class="com.ximian.evolution.mail.events:1.0">
 <event
   type="pass | sink"
   priority="signed integer"
   id="event name"
   enable="target mask" ?
   handle="function spec"/> *
 </event> *
</hook>]]></programlisting>
	  <variablelist>
	    <varlistentry>
	      <term><parameter>type</parameter></term>
	      <listitem>
		<para>
		  The event listener type.  The type maps directly to the corresponding
		  corresponding EEventItem types.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>priority</parameter></term>
	      <listitem>
		<para>
		  A signed integer specifying the priority of this event
		  listener.  0 (zero) should be used normally, although positive
		  and negative integers in the range -128 to 127 may aslo be
		  used.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>id</parameter></term>
	      <listitem>
		<para>
		  The name of the event to listen to.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>enable</parameter></term>
	      <listitem>
		<para>
		  A comma separated list of mask enumeration values used to
		  qualify when this event listener is invoked.  What values are valid
		  depend on the event hook class.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>handle</parameter></term>
	      <listitem>
		<para>
		  A plugin-type specific function specification.  This
		  function will be resolved and called when an event is routed to
		  this listener.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</sect2>
      </sect1>

      <sect1>
	<title>
	  Mail Formatter
	</title>
	<para>
	  The mail formatter plugin will invoke plugin code to format any part
	  of an email based on mime-type. There are several formatters used
	  internally by the mailer for different contexts, and each can be
	  hooked into separately, providing extensible mail formatting for
	  everything from the primary mail display, to printing, to reply
	  quoting and more. If you are implementing a handler for a given
	  mime-type, each formatter appropriate for the data-type should be
	  hooked into, so that it displays properly in all contexts.
	</para>
	<para>
	  Since the management object in this case is the same formatting
	  object as used by the core mail display engine, a plugin may override
	  or reimplement complete new functionality seamlessly.
	</para>
	<para>
	  This plugin hook isn't strictly part of the core functionality as it
	  is provided by the mail component. It however demonstrates that the
	  plugin system is extensible itself.
	</para>
      </sect1>
    </chapter>
  </part>

  <part id="reference">
    <title>
      Reference
    </title>
    <partintro>
      <para>
	This section of the book is a detailed API reference of the
	objects and methods that implement the core plugin system and hooks.
      </para>
      <para>
	It contains the detailed information required for all uses of the
	plugin system. That is, implementors
	of new hook types, application developers providing hook points, and
	plugin developers.
      </para>
    </partintro>
    <chapter>
      <title>
	EPlugin
      </title>
      <para>
	The EPlugin object manages the loading and invocation of physical
	plugin definitions and plugin binaries.  The base EPlugin class is an
	abstract class which loads plugin definitons, resolving hooks, and
	provides an api for invoking callbacks.
      </para>
      <para>
	The EPluginLib object is a concrete derived class of EPlugin which
	handles loading shared libraries using the GModule interface.
      </para>
      &e-plugin-reference;
    </chapter>

    <chapter>
      <title>
	EPopup
      </title>
      <para>
	The EPopup object manages a single popup menu.  It is used to
	application code as a convenience function for building dynamic popup
	menus based on a specific context.
      </para>
      <para>
	The EPopupHook object is loaded by
	the &EPlugin; system, and is used to provide dynamic extension to the
	application context menus.
      </para>
      &e-popup-reference;
    </chapter>

    <chapter>
      <title>
	EMenu
      </title>
      <para>
	The EMenu object manages the menus for a given view or component.  It
	is used by application code to allow the plugin system an entry point
	to current application view.  It may also be used by the application as
	a convenience function to dynamically alter the menu system based on
	user context.
      </para>
      <para>
	The EMenuHook object is loaded by the &EPlugin; system, and is used to
	provide dynamic extension to the application menus.
      </para>
      &e-menu-reference;
    </chapter>

    <chapter>
      <title>
	EConfig
      </title>
      <para>
	The EConfig object manages the building of dynamic configuration pages
	to configure specific application objects.  The same basic object can
	be used to fully drive a wizard-like druid object, or to drive a
	note-book of configuration options.  It is used by application code to
	provide the core controller in a model-view-controller implementation
	of a UI window.
      </para>
      <para>
	The EConfigHook object is loaded by the &EPlugin; system, and is used hook
	in additional configuration items into configuration windows or druids
	dynamically.
      </para>
      &e-config-reference;
    </chapter>

    <chapter>
      <title>
	EEvent
      </title>
      <para>
	The EEvent object manages broadcast of events for a given component or
	application.  It is used by application code to provide the plugin
	system with an entry point for user and system state events.
      </para>
      <para>
	The EEventHook object is loaded by the &EPlugin; system, and is used hook
	event listeners into dynamically loaded event handlers.
      </para>
      &e-event-reference;
    </chapter>
  </part>

  <part>
    <title>
      &Evolution; Hook Points.
    </title>
    <partintro>
      <para>
	This section enumerates all of the published hook points and target types
	available in each component in &Evolution;.
      </para>
    </partintro>
    <chapter>
      <title>
	Mail Hooks
      </title>
      <para>
	<emphasis>
	  Need to find out the right docbook to mark-up most of this
	  text.
	</emphasis>
      </para>
      <sect1>
	<title>Popup menus</title>
	<para>
	  The mail popup menu class is
	  <interfacename>com.ximian.evolution.mail.popup:1.0</interfacename>.
	  See the following reference section for the available targets.
	</para>

	<sect2>
	  <title>Folder Tree Context Menu</title>
	  <informaltable>
	    <tgroup cols="2">
	      <tbody>
		<row>
		  <entry>Name</entry>
		  <entry><interfacename>com.ximian.mail.storageset.popup.select</interfacename></entry>
		</row>
		<row>
		  <entry>Target</entry>
		  <entry><link linkend="API-struct--EMPopupTargetFolder">EMPopupTargetFolder</link></entry>
		</row>
		<row>
		  <entry>Widget</entry>
		  <entry>Unset</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	  <para>
	    This is the context menu shown on the folder tree.
	  </para>
	</sect2>

	<sect2>
	  <title>Message List Context Menu</title>
	  <informaltable>
	    <tgroup cols="2">
	      <tbody>
		<row>
		  <entry>Name</entry>
		  <entry><interfacename>com.ximian.mail.folderview.popup.select</interfacename></entry>
		</row>
		<row>
		  <entry>Target</entry>
		  <entry><link linkend="API-struct--EMPopupTargetSelect">EMPopupTargetSelect</link></entry>
		</row>
		<row>
		  <entry>Widget</entry>
		  <entry><link linkend="API-struct--EMFolderView">EMFolderView</link></entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	  <para>
	    This is the context menu shown on the message list.
	  </para>
	</sect2>

	<sect2>
	  <title>Inline URI Context Menu</title>
	  <informaltable>
	    <tgroup cols="2">
	      <tbody>
		<row>
		  <entry>Name</entry>
		  <entry><interfacename>com.ximian.mail.folderview.popup.uri</interfacename></entry>
		</row>
		<row>
		  <entry>Target</entry>
		  <entry><link linkend="API-struct--EMPopupTargetURI">EMPopupTargetURI</link></entry>
		</row>
		<row>
		  <entry>Widget</entry>
		  <entry>Unset</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	  <para>
	    This is the context menu shown when clicking on inline URIs,
	    including addresses or normal HTML links that are displayed inside
	    the message view.
	  </para>
	</sect2>

	<sect2>
	  <title>Inline Content and Attachment Context Menu</title>
	  <informaltable>
	    <tgroup cols="2">
	      <tbody>
		<row>
		  <entry>Name</entry>
		  <entry><interfacename>com.ximian.mail.formathtmldisplay.popup.part</interfacename></entry>
		</row>
		<row>
		  <entry>Target</entry>
		  <entry><link linkend="API-struct--EMPopupTargetPart">EMPopupTargetPart</link></entry>
		</row>
		<row>
		  <entry>Widget</entry>
		  <entry>An unspecified GtkWidget</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	  <para>
	    This context menu is shown when right-clicking on inline images, or
	    when clicking on the attachment expander button.
	  </para>
	</sect2>

	<sect2>
	  <title>Composer Attachment Bar Context Menu</title>
	  <informaltable>
	    <tgroup cols="2">
	      <tbody>
		<row>
		  <entry>Name</entry>
		  <entry><interfacename>com.novell.evolution.mail.composer.attachmentBar</interfacename></entry>
		</row>
		<row>
		  <entry>Target</entry>
		  <entry><link linkend="API-struct--EMPopupTargetAttachments">EMPopupTargetAttachments</link></entry>
		</row>
		<row>
		  <entry>Widget</entry>
		  <entry><link linkend="API-struct--EMsgComposerAttachmentBar">EMsgComposerAttachmentBar</link></entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	  <para>
	    This context menu is displayed when the user brings up a context
	    menu on the attachment bar displayed in the composer.
	  </para>
	</sect2>

	<sect2>
	  <title>Internal popup menus</title>
	  <para>
	    The following popup menus are defined, but they are used with no
	    target, and so provide no useful context if they were to be hooked
	    onto.
	  </para>
	  <para>
	    <interfacename>com.ximian.mail.messagelist.popup.drop</interfacename>
	    is used for the ASK drop type on the message list.
	  </para>
	  <para>
	    <interfacename>com.ximian.mail.storageset.popup.drop</interfacename>
	    is used for the ASK drop type on the folder tree.
	  </para>
	</sect2>
      </sect1>
      &em-popup-reference;
    </chapter>
  </part>
</book>
