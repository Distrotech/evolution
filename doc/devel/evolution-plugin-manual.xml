<?xml version='1.0'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
                  "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [

<!ENTITY Evolution "<application>Evolution</application>">
<!ENTITY GNOME "<application>GNOME</application>">
<!ENTITY eclipse "<application>Eclipse</application>">
<!ENTITY Camel "<application>Camel</application>">
<!ENTITY EPlugin "<application>EPlugin</application>">
<!ENTITY e-popup-reference SYSTEM "e-popup.xml">
<!ENTITY e-menu-reference SYSTEM "e-menu.xml">
<!ENTITY e-config-reference SYSTEM "e-config.xml">
<!ENTITY e-event-reference SYSTEM "e-event.xml">
<!ENTITY e-plugin-reference SYSTEM "e-plugin.xml">

<!ENTITY em-popup-reference SYSTEM "em-popup.xml">

]>
<?xml-stylesheet href="sdocbook.css" type="text/css"?>

<book lang="en">
  <!-- DocBook file was created by LyX 1.3
  See http://www.lyx.org/ for more information -->
  <bookinfo>
    <title>
      &Evolution; Plugin Development Manual
    </title>
    
    <authorgroup>
      <corpauthor>
	Novell, Inc.
      </corpauthor>
      <author>
	<firstname>Michael</firstname><surname>Zucchi</surname>
      </author>
    </authorgroup>

    <copyright>
      <year>2004</year>
      <holder>Novell, Inc.</holder>
    </copyright>

  </bookinfo>

  <preface id="preface">
    <title>Preface</title>

    <para>
      This document is work-in-progress.  Its structure and design is still as
      fluid as the underlying strucutre and design of some parts of EPlugin.
      There's no guarantee it will be updated at regular intervals,
      particularly this version.
    </para>
    <para>
      The API documentation is currently generated using the Linux kernel-doc
      script.  The stylesheets used to generate the HTML you're seeing seems to
      have bugs which duplicates some sections.  It is also ugly and difficult
      to navigate.
    </para>

    <sect1>
      <title>Conventions</title>
      <para>
	The following conventions are used in the manual ... (insert details
	here).
      </para>
      <sect2>
	<title>XML Annotation</title>
	<para>
	  XML definitions are annotated with BNF-style markers to indicate
	  alternative (|), multiples (* or +), and optional (?) items.  If no
	  annotation is present then the item must be present once.
	</para>
	<variablelist>
	  <varlistentry>
	    <!-- is symbol the right one here? -->
	    <term><symbol>|</symbol></term>
	    <listitem>
	      <para>Indicates an alternative option.  Only one of the items
		separated by <symbol>|</symbol> is to be chosen.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><symbol>*</symbol></term>
	    <listitem>
	      <para>Following an item, <symbol>*</symbol> indicates the item
		may occur any number of times, including no times (0 or more
		multiple).
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><symbol>+</symbol></term>
	    <listitem>
	      <para>Following an item, <symbol>+</symbol> indicates the item
		must occur at least once, but may occur more than ones (1 or
		more multiple).
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><symbol>?</symbol></term>
	    <listitem>
	      <para>Following an item, <symbol>?</symbol> indicates the item
		may occur at most once, if present (0 or 1 times).
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect2>
    </sect1>

  </preface>

  <part id="informational">
    <title>
      EPlugin
    </title>
    <chapter>
      <title>
	Introduction
      </title>
      <para>
	This book aims to be a comprehensive technical manual for the
	development of plugins for &Evolution;, a personal information manager
	for &GNOME;.
      </para>
      <para>
	Up-to, and including, &Evolution; version 2.0, &Evolution; contained
	limited extensibility interfaces. There were only two ways to extend
	&Evolution;; by implementing a new top-level component, or by
	implementing a &Camel; provider. When implementing a top-level component,
	there was still little integration, and in effect it was merely a more
	complex way of writing a separate &GNOME; application. &Camel; providers
	were only designed to be e-mail storage backends, so were of limited
	use for general extensibility. Despite this, both mechanisms were used
	for example for the Exchange Connector, although the system made the
	integration clumsy and difficult.
      </para>
      <para>
	This lack of extensibility has severaly stifled external developer
	contributions by forcing any extensions to be considered as core
	features. &Evolution; being a commercial product, it has tight usability
	and quality requirements that limits the ability to experiment with
	the core feature set in this way. As a result, very few lines of code
	or new features have been implemented by external contributors.
      </para>
      <para>
	One of the major goals for the 2.2 release was to implement an
	extensibility system, given the working name of EPlugin, which must
	provide a frame-work for both providing extensibility hooks, and for
	extending the functionality of &Evolution;.
      </para>
      <sect1>
	<title>
	  Plugin System
	</title>
	<para>
	  Any plugin system will generally have a number of goals:
	</para>
	<itemizedlist>
	  <listitem>
	    <para>
	      Provide a language independent invocation mechanism
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Allow extension of parts of the user interface and processing elements
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Require minimal extra or foreign code to implement in the core application
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Require minimal interface code to implement the extensions
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Not to impact performance or increase resource usage unduly
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Versioning
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Be able to be extended itself fairly easily.
	    </para>
	  </listitem>
	</itemizedlist>
	<para>
	  EPlugin manages to fulfill these goals in most cases. EPlugin isn't a
	  single object or interface in itself, although there is an object
	  titled EPlugin, it is a synergistic collection of integrated and
	  continually evolving objects which work together to achieve these
	  goals (and that will definitly be the end of the MarketSpeak). It
	  consists of a loader to invoke extension callbacks, hooks to resolve
	  these callbacks, targets to identify context, and managers which are
	  used by the core code to provide functionality and merging points for
	  the extensions.
	</para>
	<para>
	  EPlugin's design was inspired and influenced by the &eclipse;
	  project. It aims at a lower target however, so it was more easily
	  implemented in a practical time-frame.
	</para>
	<para>
	  The EPlugin world is awash with its own language. The next few
	  sections will introduce the basic plugin nomenclature and high-level
	  view of this world.
	</para>

      </sect1>

      <sect1>
	<title>
	  Loaders
	</title>
	<para>
	  The core of EPlugin is a light-weight object loader and callback
	  invocation system. Because of the varied calling conventions of
	  different languages, and to reduce the overhead of the plugin system
	  itself, all callbacks only receive and return a single argument. By
	  using structures to pass complex arguments, native C plugins require
	  no extra overhead, and marshalling details are moved into the plugin
	  implementation itself where required. It also simplifies memory
	  management issues significantly. For example, the C plugin handler
	  merely loads a shared library using GModule, and resolves a symbol by
	  name; and is so all of 50 lines of code, total. The loaders are the
	  only modules which need to interace with non-native code or
	  conventions.
	</para>
	<para>
	  The other task of the plugin core is to load XML definitions of the
	  plugins. Extension hooks are registered with the plugin core before
	  the plugins are scanned, and are automatically instantiated to load
	  each definition appropriately as they are encountered.
	</para>
	<para>
	  At each layer, a level of indirection is used so that new loaders and
	  new hooks can be added transparently, and extend the plugin
	  definition freely with any information they require.
	</para>
      </sect1>

      <sect1>
	<title>
	  Hooks
	</title>
	<para>
	  The hooks
	  <footnote>
	    <para>A hook is something you can hang your stuff on.</para>
	  </footnote>
	  which are registered with the loader provide meta-data for
	  the management implementation layer for extending it at
	  run-time. Their primary
	  functions are to load the detail of the XML plugin definition, map it
	  to the implementation, and marshal the implementation callbacks to
	  the common plugin interface. How they do this depends on the
	  implementation itself, and ranges from registering factory methods to
	  simply adding the items directly.
	</para>
	<para>
	  In most cases the physical object need not be loaded until the
	  callback is invoked, since the plugin definitions provide enough
	  contextual information to build the interface or determine when they
	  need to be invoked.
	</para>
      </sect1>

      <sect1>
	<title>
	  Managers
	</title>
	<para>
	  Managers
	  <footnote>
	    <para>
	      Unlike real managers, these are the ones that do the heavy lifting.
	    </para>
	  </footnote>
	  provide tools for the core code to extend itself at specific
	  points, and in many cases are the objects used directly in the code
	  to implement core features. In other cases they simply provide the
	  hooks with an entry point into &Evolution;. For example, for the main
	  menu hook, the manager is a thin layer to BonoboUI. On the other
	  hand, EPopup is a complete implementation of a popup menu management
	  system which was already used in &Evolution; 2.0. Some managers are
	  one-off objects used as constructors for other objects, others are
	  view-dependent, and some are static objects, such as the Event
	  routers.
	</para>
      </sect1>

      <sect1>
	<title>
	  Items
	</title>
	<para>
	  Each manager uses a number of items to describe the object they
	  control or create. The items are added to each manager instance from
	  the plugins or from core code. The items from all of these sources
	  are then merged together when required and processed accordingly. For
	  example, menu items are merged into the display format. Events on the
	  other hand are simply ordered and then invoked in the order of their
	  priority. Items are part of the manager implementation, and in
	  EPlugin they are all extensible objects too, which the hooks use to
	  perform mapping to the plugin. Items may be extended by code hooking
	  into the implementation, either the plugin hooks, or the core code.
	</para>
      </sect1>

      <sect1>
	<title>
	  Targets
	</title>
	<para>
	  Targets
	  <footnote><para>Think of a target as the target of
	      interest.</para></footnote>
	  are view or component specific context objects. They contain
	  enough information to be used as stand-alone contexts to implement
	  callbacks for both core functions and plugin hooks. For example for
	  the mail view, a select target contains a folder and a list of
	  selected messages. An attachment (part) target contains the
	  &Camel; representation of the part and the mime-type for
	  that part. Targets are part of the manager implementation and are
	  extended by subclassing the manager.
	</para>
      </sect1>
    </chapter>

    <chapter id="plugin-loaders">
      <title>
	Plugin Loaders
      </title>
      <para>
	Plugin loaders implement a hool to a new language, or loading system in the
	plugin system.  The actual binding of new languages to the plugin system or
	other parst of &Evolution;s api's are beyond the scope of this
	document, some languages make this easier than others.
      </para>
      <sect1 id="plugin-loaders-base">
	<title>
	  Base Plugin
	</title>
	<para>
	  The <link linkend="API-struct--EPlugin">EPlugin base class</link>
	  is an abstract class which provides the basic services for plugin
	  implementations. The main services are:
	  <itemizedlist>
	    <listitem><para>Resolve plugin type and instantiate an EPlugin
		object to represent and manage it.</para></listitem>
	    <listitem><para>Load the base structure of the XML plugin
		definition files.</para></listitem>
	    <listitem><para>Resolve plugin hook types and instantiate a
		EPluginHook to represent and manage it.</para></listitem>
	    <listitem><para>Provide a simple, language-independent api for
		invoking plugin callbacks</para></listitem>
	    <listitem><para>Provide I18N context for plugins.</para></listitem>
	    <listitem><para>Some simple static helper methods to simplify each
		implementing class.</para></listitem>
	  </itemizedlist>
	  See the <link linkend="REF-EPlugin">EPlugin reference section</link> for
	  these details.
	</para>

	<sect2 id="plugin-loaders-definition">
	  <title>Definition of a Plugin</title>
	  <para>
	    The base plugin XML definition.  Subclasses of EPlugin extend this
	    basic structure with additional parameters or elements as they
	    require.
	  </para>
	  <para>
	    Note that there may be any number of <sgmltag>e-plugin</sgmltag>
	    elements in a given plugin file, this may be used to simplify
	    distribution of plugin packages.
	  </para>
	  <programlisting>
	    <![CDATA[
<?xml version="1.0">
<e-plugin-list>
  <e-plugin
    type="loader type"
    domain="translation domain" ?
    name="plugin name"
    ...>
    <description>long description</description> ?
    <hook
      class="hook class"
      ...>
    ...
    </hook> +
  </e-plugin> +
</e-plugin-list>]]></programlisting>
	  <variablelist>
	    <varlistentry>
	      <term><parameter>type</parameter></term>
	      <listitem>
		<para>
		  The type name of the plugin loader.  Currently <link
		    linkend="plugin-loaders-lib">shlib</link> and <link
		    linkend="plugin-loaders-mono">mono</link> are the only
		  supported values.  If no known handler is registered for this
		  type, the plugin definition is silently ignored.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>domain</parameter></term>
	      <listitem>
		<para>
		  The translation domain for this plugin, as passed to the
		  <function>dcgettext</function> call of the gettext package.
		  If not supplied then the default application domain is used
		  (i.e. &quot;evolution&quot;).  This is used to translate
		  translatable strings for display.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>name</parameter></term>
	      <listitem>
		<para>
		  A short name for the plugin.  &quot;Bob's Wonder
		  Extender&quot; might be suitable.  This value will be
		  translated.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>description</parameter></term>
	      <listitem>
		<para>
		  A longer description of the plugin's purpose. This value will be
		  translated.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>hook</parameter></term>
	      <listitem>
		<para>
		  This is a list of all of the hooks that this plugin wishes to
		  hook into.  See the <link linkend="plugin-hooks">Plugin
		    Hooks</link> section for the details of the basic hook
		  types defined.
		</para>
		<para>
		  The hook <parameter>class</parameter> is resolved using the
		  registered hook types, and if none can be found, or a version
		  mismatch occurs, then the hook is silently ignored.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</sect2>
      </sect1>

      <sect1 id="plugin-loaders-lib">
	<title>
	  Shared Library Loader
	</title>
	<para>
	  The shared library loader <link
	    linkend="API-struct--EPluginLib">EPluginLib</link> implements a
	  concrete EPlugin type which loads GNU shared libraries via the
	  GModule api.  It simply resolves symbols directly from the loaded
	  shared object and invokes them with the same arguments as the
	  <link linkend="API-e-plugin-invoke">e_plugin_invoke</link> method.
	</para>

	<sect2 id="plugin-loaders-lib-definition">
	  <title>Definition</title>
	  <para>The shared library loader only requires one extra parameter in
	    the base plugin definition.
	  </para>
	  <programlisting>
	    <![CDATA[
<e-plugin
  ...
  type="shlib"
  location="/full/path/name.so"
  ...
  <hook class="...">
   ...
</e-plugin>]]></programlisting>
	  <variablelist>
	    <varlistentry>
	      <term><parameter>type</parameter></term>
	      <listitem>
		<para>
		  The type name of the shared library plugin is
		  <constant>shlib</constant>.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>location</parameter></term>
	      <listitem>
		<para>
		  The location parameter contains
		  the full path-name of a shared object to load.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</sect2>

	<sect2 id="plugin-loaders-lib-invocation">
	  <title>Invocation</title>
	  <simplesect>
	    <title>Function specification
	    </title>
	    <para>Where a function spec is required in a plugin
	      hook definition, it should simply be the full name of an
	      exported symbol in the shared object.
	    </para>
	  </simplesect>
	  <simplesect>
	    <title>Callback signature</title>
	    <funcsynopsis><funcprototype>
		<funcdef>void * <function>function</function></funcdef>
		<paramdef>EPlugin * <parameter>ep</parameter></paramdef>
		<paramdef>void * <parameter>data</parameter></paramdef>
	      </funcprototype></funcsynopsis>
	    <variablelist>
	      <varlistentry>
		<term><function>function</function></term>
		<listitem>
		  <para>
		    The callback function.
		  </para>
		</listitem>
	      </varlistentry>
	      <varlistentry>
		<term><parameter>ep</parameter></term>
		<listitem>
		  <para>
		    The container EPlugin representing this plugin.
		  </para>
		</listitem>
	      </varlistentry>
	      <varlistentry>
		<term><parameter>data</parameter></term>
		<listitem>
		  <para>
		    Hook context data.  It is part of the hook's api to specify
		    the type of this pointer.
		  </para>
		</listitem>
	      </varlistentry>
	      <varlistentry>
		<term><returnvalue>return value</returnvalue></term>
		<listitem>
		  <para>
		    Return data.  It is part of the hook's api to specify the
		    type of this pointer.
		  </para>
		</listitem>
	      </varlistentry>
	    </variablelist>
	  </simplesect>
	</sect2>
      </sect1>

      <sect1 id="plugin-loaders-mono">
	<title>
	  Mono Assembly Loader
	</title>
	<para>
	  The mono assembly loader <link
	    linkend="API-struct--EPluginMono">EPluginMono</link> implements a
	  concrete EPlugin type which loads C# assemblies using Mono.  Apart
	  from loading the assembly, it can optionally instantiate a class to
	  implement the callback or invoke static methods directly.
	</para>

	<sect2 id="plugin-loaders-mono-definition">
	  <title>Definition</title>
	  <para>The mono assembly loader needs the name of the assembly and
	    optionally the name of the class for handling the callbacks.
	  </para>
	  <programlisting>
	    <![CDATA[
<e-plugin
  ...
  type="mono"
  location="/full/path/name.dll"
  handler="PluginClass" ?
  ...
  <hook class="...">
   ...
</e-plugin>]]></programlisting>
	  <variablelist>
	    <varlistentry>
	      <term><parameter>type</parameter></term>
	      <listitem>
		<para>
		  The type name of a mono assembly plugin is
		  <constant>mono</constant>.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>location</parameter></term>
	      <listitem>
		<para>
		  The location parameter contains
		  the full path-name of an assembly to load.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>handler</parameter></term>
	      <listitem>
		<para>
		  If supplied, the handler contains the fully qualified name of
		  the class which handles all callbacks for this plugin.  If a
		  handling class is used, then the function specifications
		  become relative to this class.
		</para>
		<para>
		  This class will be
		  instantiated once upon the first callback invocation, and
		  remain active for the life of the plugin (or application).
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</sect2>

	<sect2 id="plugin-loaders-mono-invocation">
	  <title>Invocation</title>
	  <simplesect>
	    <title>Function specification
	    </title>
	    <para>If no <parameter>handler</parameter> class is specified, then
	      the function specification must match a static method in the
	      assembly.  This is passed to <function>mono_method_desc_new</function>
	      and <function>mono_method_desc_search_in_image</function>,
	      typically <function>FunctionName(intptr)</function>.
	    </para>
	    <para>
	      If the handler is specified, then the function specification is
	      relative to the handler class.  This is passed to
	      <function>mono_method_desc_new</function> and
	      <function>mono_method_desc_search_in_class</function>, typically
	      <function>:MethodName(intptr)</function>.
	    </para>
	  </simplesect>
	  <simplesect>
	    <title>Callback signature</title>
	    <funcsynopsis><funcprototype>
		<funcdef>IntPtr<function>function</function></funcdef>
		<paramdef>IntPtr<parameter>data</parameter></paramdef>
	      </funcprototype></funcsynopsis>
	    <variablelist>
	      <varlistentry>
		<term><function>function</function></term>
		<listitem>
		  <para>
		    The callback method.
		  </para>
		</listitem>
	      </varlistentry>
	      <varlistentry>
		<term><parameter>data</parameter></term>
		<listitem>
		  <para>
		    The hook context data.  This is a pointer to unmanaged data, and it is up-to the plugin to interpret this
		    data right now, although some helper binding classes are
		    planned.  FIXME: hook-up when they and doco are done.
		  </para>
		</listitem>
	      </varlistentry>
	      <varlistentry>
		<term><returnvalue>return value</returnvalue></term>
		<listitem>
		  <para>
		    The callback return data.  It is up to the hook's api to
		    define the type of this pointer.  It may be a simple boxed
		    value type, or a memory pointer allocated in unmanaged memory (e.g. a
		    GObject handle or a CamelObject cobject value).
		  </para>
		</listitem>
	      </varlistentry>
	    </variablelist>
	  </simplesect>
	</sect2>
      </sect1>

    </chapter>

    <chapter id="plugin-hooks">
      <title>
	Plugin Hooks
      </title>
      <para>
	This chapter will introduce the available plugin hook types. A given
	plugin can hook into any of these hooks any number of times. Some refer
	to specific instances of objects and others are implicitly defined.
      </para>
      <para>
	By design, there is considerable similarity and orthogonality amongst
	all of the various hook types and management objects.
      </para>
      <sect1 id="plugin-hooks-popup">
	<title>
	  Popup Menus
	</title>
	<para>
	  The popup menu hook lets you hook into any of the context menus in
	  &Evolution;, by name and context. Complex, dynamic, and multi-level
	  menus are created on the fly by merging the items for a given menu as
	  it is being shown. Each component provides its own context targets to
	  self-describe the situation under which the menu is invoked. Plugins
	  and core code alike are then invoked at the user's direction. The
	  popup manager and all context data lives as long as the menu and
	  until a choice is made, simplifying memory management.
	</para>
	<para>
	  The menu is merged from multiple plugins and core application code by
	  using a simple lexiographical sort of an absolute path to the menu
	  item. This merged list is then scanned and expanded into a tree of
	  menus. Individual items can be hidden or inactive based on the target
	  and a simple mask which is defined by the component itself. A rich
	  collection of menu item types are possible, from simple, to
	  checkboxes or images. The popup code is simple, and easy to use, and
	  simplifies the use of popup menu's in the core application anyway,
	  that they are pluggable is a free-bonus.
	</para>
	<sect2>
	  <title>Defining a popup hook</title>
	  <para>
	    Not sure if this fits here as such.  Probably temporary placeholder.
	  </para>
	  <programlisting>
	    <![CDATA[
<hook class="com.ximian.evolution.mail.popup:1.0">
 <menu id="menuid" target="targettype">
  <item
   type="item | toggle | radio | image | submenu | bar"
   active ?
   path="foo/bar"
   label="menu text"
   icon="icon name" ?
   visible="target mask" ?
   enable="target mask" ?
   activate="function spec"/> *
 </menu> *
</hook>]]></programlisting>
	  <!-- this is all too bloody verbose, is there a better way? -->
	  <para>
	    <emphasis>Need to define menu tag</emphasis>
	  </para>
	  <variablelist>
	    <varlistentry>
	      <term><parameter>type</parameter></term>
	      <listitem>
		<para>
		  The menu item type.  The type maps directly to the
		  corresponding EPopupItem types.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>active</parameter></term>
	      <listitem>
		<para>
		  If present, then radio or toggle menu items are active when
		  first shown.  After the first instantiation, they will
		  remember their active state.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>path</parameter></term>
	      <listitem>
		<para>
		  A '/' separated path used to position the item within menu
		  and in the right submenu.  Each menu and plugin should
		  define how its menu's are layed out so other plugins can
		  determine what value to use here.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>label</parameter></term>
	      <listitem>
		<para>
		  The text to be displayed on the menu item.  This will be
		  translated based on the plugin translation domain (FIXME:
		  domain's are not yet available).
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>icon</parameter></term>
	      <listitem>
		<para>
		  The name of a gnome-icon-theme standard icon, or the full
		  path-name of an icon image to use as menu item icon.  This
		  will be blank if not supplied.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>visible</parameter></term>
	      <listitem>
		<para>
		  A comma separated list of mask enumeration values used to
		  define when this item is shown.  What values are valid
		  depend on the menu hook class of the menu being hooked
		  onto.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>enable</parameter></term>
	      <listitem>
		<para>
		  A comma separated list of mask enumeration values used to
		  define when this item is enabled.  What values are valid
		  depend on the menu hook class of the menu being hooked
		  onto.  This is currently unimplemented.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>activate</parameter></term>
	      <listitem>
		<para>
		  A plugin-type specific function specification.  This
		  function will be resolved and called when the menu item is
		  activated.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</sect2>
      </sect1>

      <sect1 id="plugin-hooks-menu">
	<title>
	  Main menus
	</title>
	<para>
	  The main menu hook lets you hook into various main menus in
	  &Evolution;, based on the current active view (component). The system
	  works by piggy-backing on the existing use of the BonoboUI menu
	  system used by all of the &Evolution; components. Bonobo handles the
	  menu merging and user input, and the hook resolves the verb being
	  invoked and redirects it to the plugin. Each view defines a single
	  target which describes the appropriate context. For the Mail view,
	  this is the current folder and currently selected message(s).
	</para>
	<para>
	  Each view keeps track of its own manager object. When it is
	  (de)activated, it also (de)activates the management object which
	  dynamically adds and removes the menu items from the
	  BonoboUIContainer via a supplied BonoboUI XML definition file
	  &lt;perhaps it should embed the bonobouixml&gt;. If the target
	  changes, the view lets the manager know, and it updates the
	  visibility and sensitivity of objects appropriately, allowing
	  reasonably dynamic user-interfaces to be managed automatically. The
	  plugin itself isn't loaded until the menu item in question is invoked
	</para>
	<para>
	  Simple menu items and toggle menu items are supported currently.
	</para>
	<sect2>
	  <title>Defining a menu hook</title>
	  <para>
	    Not sure if this fits here as such.  Probably temporary placeholder.
	  </para>
	  <programlisting>
	    <![CDATA[
<hook class="com.ximian.evolution.mail.bonoboMenu:1.0">
 <menu id="menuid" target="targettype">
  <item
   type="item | toggle | radio"
   active ?
   path="/commands/FooBar"
   verb="FooBar"
   visible="target mask" ?
   enable="target mask" ?
   activate="function spec"/> *
 </menu> *
</hook>]]></programlisting>
	  <para>
	    <emphasis>Need to define menu tag</emphasis>
	  </para>
	  <variablelist>
	    <varlistentry>
	      <term><parameter>type</parameter></term>
	      <listitem>
		<para>
		  The menu item type.  The type maps directly to the
		  corresponding EMenuItem types.
		  <parameter>radio</parameter> is currently not implemented.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>active</parameter></term>
	      <listitem>
		<para>
		  If present, then radio or toggle menu items are active when
		  first shown.  After the first instantiation, they will
		  remember their active state.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>path</parameter></term>
	      <listitem>
		<para>
		  The BonoboUI element path corresponding to this menu item.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>verb</parameter></term>
	      <listitem>
		<para>
		  The BonoboUI verb corresponding to the item to be listened to.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>visible</parameter></term>
	      <listitem>
		<para>
		  A comma separated list of mask enumeration values used to
		  define when this item is shown.  What values are valid
		  depend on the menu hook class of the menu being hooked
		  onto.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>enable</parameter></term>
	      <listitem>
		<para>
		  A comma separated list of mask enumeration values used to
		  define when this item is sensitive.  What values are valid
		  depend on the menu hook class of the menu being hooked
		  onto.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>activate</parameter></term>
	      <listitem>
		<para>
		  A plugin-type specific function specification.  This
		  function will be resolved and called when the menu item is
		  activated.  The funciton's parameters will depend on the type
		  of menu item being invoked.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</sect2>
      </sect1>

      <sect1 id="plugin-hooks-config">
	<title>
	  Configuration Pages and Wizards
	</title>
	<para>
	  Configuration pages are somewhat more complex than any of the other
	  types of hookable object. This is reflected in the complexity of the
	  items and callbacks involved.
	</para>
	<para>
	  Essentially, the EConfig object is used in combination to both
	  instrument existing windows and building new content.  Each
	  configuration window comprises of several basic elements with some
	  minor variations allowed.  It consists of a number of pages in a
	  specific order, each containing a number of titled sections in a specific
	  order, each containing a number of items.  The variations are that
	  the top-level widget may be a GtkNotebook or a GnomeDruid; and each
	  section may instrument a GtkBox, or a GtkTable.  The definition of
	  the available hooks will define what form they take.
	</para>
	<para>
	  The EConfig manager uses the description of all the items supplied to
	  it to build the complete window.  It can also drive various aspects
	  of the UI, such as navigating through a druid or handling
	  instant-apply vs. modify-and-save dialogues.
	</para>
	<figure>
	  <title>Event and Data Flow in EMConfig</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="images/e-config-flow.pic" format="PIC"/>
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="images/e-config-flow.png" format="PNG"/>
	    </imageobject>
	    <textobject>
	      <phrase>A flow of information and control signals in the
		configuration management object.</phrase>
	    </textobject>
	  </mediaobject>
	</figure>

	<sect2>
	  <title>Defining a configuration page hook</title>
	  <para>
	    Not sure if this fits here as such.  Probably temporary placeholder.
	  </para>
	  <programlisting>
	    <![CDATA[
<hook class="com.ximian.evolution.mail.bonoboMenu:1.0">
 <group
  id="window id"
  target="targettype"
  commit="function spec"?
  abort="function spec"?>
  <item
   type="book | druid | page | page_start | page_finish | section | section_table | item"
   path="/absolute/path"
   label="name" | factory="function  spec"
  /> *
 </menu> *
</hook>]]></programlisting>
	  <para>
	    <emphasis>Need to define group tag</emphasis>
	  </para>
	  <variablelist>
	    <varlistentry>
	      <term><parameter>type</parameter></term>
	      <listitem>
		<para>
		  The menu item type.  The type maps directly to the
		  corresponding EConfigItem types.  Only one of
		  <parameter>book</parameter> and <parameter>druid</parameter>
		  may be supplied for the entire configuration page, and this
		  will usually already be defined by the application.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>path</parameter></term>
	      <listitem>
		<para>
		  The path to the configuration item in question.  This is a
		  simple string that when sorted using an ASCII sort will place
		  the items in the right order.  That is, sections before items
		  before pages before the root object.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>label</parameter></term>
	      <listitem>
		<para>
		  The textual label of this item.  This may only be supplied
		  for the section and page types.  For sections it will be the
		  section frame text.  For pages this will be the druid page
		  title or the notebook tab text.  If a
		  <parameter>factory</parameter>is supplied then this value is
		  not used.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>factory</parameter></term>
	      <listitem>
		<para>
		  If supplied, the factory method used to create the GtkWidget
		  elements for this configuration item.  Factories may be
		  supplied for any of the item types.  If no
		  <parameter>label</parameter> is set then the
		  <parameter>factory</parameter> must be set.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</sect2>
      </sect1>

      <sect1 id="plugin-hooks-event">
	<title>
	  Events
	</title>
	<para>
	  No extensibility framework would be complete without an event
	  system. Events are used to reflect changes in internal state of the
	  application, and track actions by the user. They can contain any
	  information and additionally can be filtered based on the information
	  itself. Special targets are used, as in the other plugin hooks, to
	  hold this information.
	</para>
	<para>
	  Event managers are defined to contain the different event types that
	  a given component can export. Only one event manager object is
	  instantiated for each component, and each plugin listening to events
	  from that component are registered on that event manager directly.
	</para>
	<para>
	  Events handlers have priorities, and can swallow events, allowing
	  some level of complexity of event routing. This feature might not
	  prove useful and may be removed in the future if it isn't.
	</para>
	<sect2>
	  <title>Defining an event hook</title>
	  <para>
	    Not sure if this fits here as such.  Probably temporary placeholder.
	  </para>

	  <programlisting>
	    <![CDATA[
<hook class="com.ximian.evolution.mail.events:1.0">
 <event
   type="pass | sink"
   priority="signed integer"
   id="event name"
   enable="target mask" ?
   handle="function spec"/> *
 </event> *
</hook>]]></programlisting>
	  <variablelist>
	    <varlistentry>
	      <term><parameter>type</parameter></term>
	      <listitem>
		<para>
		  The event listener type.  The type maps directly to the corresponding
		  corresponding EEventItem types.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>priority</parameter></term>
	      <listitem>
		<para>
		  A signed integer specifying the priority of this event
		  listener.  0 (zero) should be used normally, although positive
		  and negative integers in the range -128 to 127 may aslo be
		  used.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>id</parameter></term>
	      <listitem>
		<para>
		  The name of the event to listen to.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>enable</parameter></term>
	      <listitem>
		<para>
		  A comma separated list of mask enumeration values used to
		  qualify when this event listener is invoked.  What values are valid
		  depend on the event hook class.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter>handle</parameter></term>
	      <listitem>
		<para>
		  A plugin-type specific function specification.  This
		  function will be resolved and called when an event is routed to
		  this listener.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</sect2>
      </sect1>

      <sect1 id="plugin-hooks-format">
	<title>
	  Mail Formatter
	</title>
	<para>
	  The mail formatter plugin will invoke plugin code to format any part
	  of an email based on mime-type. There are several formatters used
	  internally by the mailer for different contexts, and each can be
	  hooked into separately, providing extensible mail formatting for
	  everything from the primary mail display, to printing, to reply
	  quoting and more. If you are implementing a handler for a given
	  mime-type, each formatter appropriate for the data-type should be
	  hooked into, so that it displays properly in all contexts.
	</para>
	<para>
	  Since the management object in this case is the same formatting
	  object as used by the core mail display engine, a plugin may override
	  or reimplement complete new functionality seamlessly.
	</para>
	<para>
	  This plugin hook isn't strictly part of the core functionality as it
	  is provided by the mail component. It however demonstrates that the
	  plugin system is extensible itself.
	</para>
      </sect1>
    </chapter>
  </part>

  <part>
    <title>
      &Evolution; Hook Points.
    </title>
    <partintro>
      <para>
	This section enumerates all of the published hook points and target
	types available in each component in &Evolution;.
      </para>

      <simplesect>
	<title>Table Format</title>
	<informaltable>
	  <tgroup cols="2">
	    <tbody>
	      <row>
		<entry>Name</entry>
		<entry>The hook point id.</entry>
	      </row>
	      <row>
		<entry>Target</entry>
		<entry>Which C structure defines the target this hook uses.
		  The name used in a plugin to identify this target, and the
		  plugin names used to define the target qualifiers if they
		  exist for this hook type.
		  Whether the
		  <structname>Target</structname><structfield>widget</structfield> field has a known value.
		</entry>
	      </row>
	      <row>
		<entry>Qualifiers</entry>
		<entry><para>
		    A list showing the mapping of the plugin qualifier name,
		    and the actual qualifier value.  This is only defined where
		    qualifiers exist.
		    </para>
		  <para><emphasis>These should actually just be defined by
		      target descriptions, since multiple hook points can use
		      the same target</emphasis>
		  </para>
		</entry>
	      </row>
	      <row>
		<entry>Items</entry>
		<entry>If appropriate and defined, specifies identifying path
		  names of items which make up the hook.  e.g. popup menu
		  items, and configuration pages.  These item specifications
		  allow the plugin writer to position their items
		  appropriately.
		</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </simplesect>

    </partintro>
    <chapter id="mail-hooks">
      <title>
	Mail Hooks
      </title>
      <para>
	<emphasis>
	  Need to find out the right docbook to mark-up most of this
	  text.
	</emphasis>
      </para>

      <sect1 id="mail-hooks-popup">
	<title>Popup menus</title>

	  <para>
	    The mail popup menu class is
	    <interfacename>com.ximian.evolution.mail.popup:1.0</interfacename>.
	  </para>
	  <para>
	    The plugin callback data will be the target matching the plugin
	    menu itself, and the callback returns no value.
	  </para>

	<sect2>
	  <title>Folder Tree Context Menu</title>
	  <informaltable>
	    <tgroup cols="2">
	      <tbody valign="top">
		<row>
		  <entry>Name</entry>
		  <entry><interfacename>com.ximian.mail.storageset.popup.select</interfacename></entry>
		</row>
		<row>
		  <entry>Target</entry>
		  <entry>
		    <link
		      linkend="API-struct--EMPopupTargetFolder">EMPopupTargetFolder</link>, plugin target is &quot;<constant>folder</constant>&quot;.
		  </entry>
		</row>
		<row>
		  <entry>Qualifiers</entry>
		  <entry>
		    <simplelist>
		      <member><constant>folder</constant> = <constant>EM_POPUP_FOLDER_FOLDER</constant></member>
		      <member><constant>store</constant> = <constant>EM_POPUP_FOLDER_STORE</constant></member>
		      <member><constant>inferiors</constant> = <constant>EM_POPUP_FOLDER_INFERIORS</constant></member>
		      <member><constant>delete</constant> = <constant>EM_POPUP_FOLDER_DELETE</constant></member>
		      <member><constant>select</constant> = <constant>EM_POPUP_FOLDER_SELECT</constant></member>
		    </simplelist>
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	  <para>
	    This is the context menu shown on the folder tree.
	  </para>
	</sect2>

	<sect2>
	  <title>Message List Context Menu</title>
	  <informaltable>
	    <tgroup cols="2">
	      <tbody valign="top">
		<row>
		  <entry>Name</entry>
		  <entry><interfacename>com.ximian.mail.folderview.popup.select</interfacename></entry>
		</row>
		<row>
		  <entry>Target</entry>
		  <entry>
		    <link
		      linkend="API-struct--EMPopupTargetSelect">EMPopupTargetSelect</link>, plugin target is &quot;<constant>select</constant>&quot;.  The <structfield>widget</structfield> is an <link linkend="API-struct--EMFolderView">EMFolderView</link>
		  </entry>
		</row>
		<row>
		  <entry>Qualifiers</entry>
		  <entry>
		    <para><emphasis>This info should probably just be in the target
		      reference info, otherwise it may be redundant.  It could
		      also be auto-generated from the source.</emphasis>
		    </para>
		    <simplelist>
		      <member><constant>one</constant> = <constant>EM_POPUP_SELECT_ONE</constant></member>
		      <member><constant>many</constant> = <constant>EM_POPUP_SELECT_MANY</constant></member>
		      <member><constant>mark_read</constant> = <constant>EM_POPUP_SELECT_MARK_READ</constant></member>
		      <member><constant>mark_unread</constant> = <constant>EM_POPUP_SELECT_MARK_UNREAD</constant></member>
		      <member><constant>delete</constant> = <constant>EM_POPUP_SELECT_DELETE</constant></member>
		      <member><constant>undelete</constant> = <constant>EM_POPUP_SELECT_UNDELETE</constant></member>
		      <member><constant>mailing_list</constant> = <constant>EM_POPUP_SELECT_MAILING_LIST</constant></member>
		      <member><constant>resend</constant> = <constant>EM_POPUP_SELECT_EDIT</constant></member>
		      <member><constant>mark_important</constant> = <constant>EM_POPUP_SELECT_MARK_IMPORTANT</constant></member>
		      <member><constant>mark_unimportant</constant> = <constant>EM_POPUP_SELECT_MARK_UNIMPORTANT</constant></member>
		      <member><constant>flag_followup</constant> = <constant>EM_POPUP_SELECT_FLAG_FOLLOWUP</constant></member>
		      <member><constant>flag_completed</constant> = <constant>EM_POPUP_SELECT_FLAG_COMPLETED</constant></member>
		      <member><constant>flag_clear</constant> = <constant>EM_POPUP_SELECT_FLAG_CLEAR</constant></member>
		      <member><constant>add_sender</constant> = <constant>EM_POPUP_SELECT_ADD_SENDER</constant></member>
		      <member><constant>mark_junk</constant> = <constant>EM_POPUP_SELECT_MARK_JUNK</constant></member>
		      <member><constant>mark_nojunk</constant> = <constant>EM_POPUP_SELECT_MARK_NOJUNK</constant></member>
		      <member><constant>folder</constant> = <constant>EM_POPUP_SELECT_FOLDER</constant></member>
		    </simplelist>
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	  <para>
	    This is the context menu shown on the message list.
	  </para>
	</sect2>

	<sect2>
	  <title>Inline URI Context Menu</title>
	  <informaltable>
	    <tgroup cols="2">
	      <tbody valign="top">
		<row>
		  <entry>Name</entry>
		  <entry><interfacename>com.ximian.mail.folderview.popup.uri</interfacename></entry>
		</row>
		<row>
		  <entry>Target</entry>
		  <entry><link
		      linkend="API-struct--EMPopupTargetURI">EMPopupTargetURI</link>, plugin target is &quot;<constant>uri</constant>&quot;</entry>
		</row>
		<row>
		  <entry>Qualifiers</entry>
		  <entry>
		    <simplelist>
		      <member><constant>http</constant> = <constant>EM_POPUP_URI_HTTP</constant></member>
		      <member><constant>mailto</constant> = <constant>EM_POPUP_URI_MAILTO</constant></member>
		      <member><constant>notmailto</constant> = <constant>EM_POPUP_URI_NOT_MAILTO</constant></member>
		    </simplelist>
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	  <para>
	    This is the context menu shown when clicking on inline URIs,
	    including addresses or normal HTML links that are displayed inside
	    the message view.
	  </para>
	</sect2>

	<sect2>
	  <title>Inline Content and Attachment Context Menu</title>
	  <informaltable>
	    <tgroup cols="2">
	      <tbody valign="top">
		<row>
		  <entry>Name</entry>
		  <entry><interfacename>com.ximian.mail.formathtmldisplay.popup.part</interfacename></entry>
		</row>
		<row>
		  <entry>Target</entry>
		  <entry><link
		      linkend="API-struct--EMPopupTargetPart">EMPopupTargetPart</link>, plugin target is &quot;<constant>part</constant>&quot;</entry>
		</row>
		<row>
		  <entry>Qualifiers</entry>
		  <entry>
		    <simplelist>
		      <member><constant>message</constant> = <constant>EM_POPUP_PART_MESSAGE</constant></member>
		      <member><constant>image</constant> = <constant>EM_POPUP_PART_IMAGE</constant></member>
		    </simplelist>
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	  <para>
	    This context menu is shown when right-clicking on inline images, or
	    when clicking on the attachment expander button.
	  </para>
	</sect2>

	<sect2>
	  <title>Composer Attachment Bar Context Menu</title>
	  <informaltable>
	    <tgroup cols="2">
	      <tbody valign="top">
		<row>
		  <entry>Name</entry>
		  <entry><interfacename>com.novell.evolution.mail.composer.attachmentBar</interfacename></entry>
		</row>
		<row>
		  <entry>Target</entry>
		  <entry><link
		      linkend="API-struct--EMPopupTargetAttachments">EMPopupTargetAttachments</link>, plugin target is &quot;<constant>attachments</constant>&quot;.  The <structfield>widget</structfield> is an <link linkend="API-struct--EMsgComposerAttachmentBar">EMsgComposerAttachmentBar</link>.
</entry>
		</row>
		<row>
		  <entry>Qualifiers</entry>
		  <entry>
		    <simplelist>
		      <member><constant>one</constant> = <constant>EM_POPUP_ATTACHMENTS_ONE</constant></member>
		      <member><constant>many</constant> = <constant>EM_POPUP_ATTACHMENTS_MANY</constant></member>
		    </simplelist>
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	  <para>
	    This context menu is displayed when the user brings up a context
	    menu on the attachment bar displayed in the composer.
	  </para>
	</sect2>

	<sect2>
	  <title>Internal popup menus</title>
	  <para>
	    The following popup menus are defined, but they are used with no
	    target, and so provide no useful context if they were to be hooked
	    onto.
	  </para>
	  <para>
	    <interfacename>com.ximian.mail.messagelist.popup.drop</interfacename>
	    is used for the ASK drop type on the message list.
	  </para>
	  <para>
	    <interfacename>com.ximian.mail.storageset.popup.drop</interfacename>
	    is used for the ASK drop type on the folder tree.
	  </para>
	</sect2>
      </sect1>

      <sect1 id="mail-hooks-menu">
	<title>Main menus</title>

	  <para>
	    The mail popup menu class is
	    <interfacename>com.ximian.evolution.mail.bonobomenu:1.0</interfacename>.
	  </para>
	  <para>
	    The plugin callback data will be the target matching the plugin
	    menu itself, and the callback returns no value.
	  </para>

	<sect2>
	  <title>Main Mail Menu</title>
	  <informaltable>
	    <tgroup cols="2">
	      <tbody valign="top">
		<row>
		  <entry>Name</entry>
		  <entry><interfacename>com.novell.evolution.mail.browser</interfacename></entry>
		</row>
		<row>
		  <entry>Target</entry>
		  <entry>
		    <link
		      linkend="API-struct--EMMenuTargeSelect">EMMenuTargetSelect</link>, plugin target is &quot;<constant>select</constant>&quot;.
		  </entry>
		</row>
		<row>
		  <entry>Qualifiers</entry>
		  <entry>
		    <simplelist>
		      <member><constant>one</constant> = <constant>EM_MENU_SELECT_ONE</constant></member>
		      <member><constant>many</constant> = <constant>EM_MENU_SELECT_MANY</constant></member>
		      <member><constant>mark_read</constant> = <constant>EM_MENU_SELECT_MARK_READ</constant></member>
		      <member><constant>mark_unread</constant> = <constant>EM_MENU_SELECT_MARK_UNREAD</constant></member>
		      <member><constant>delete</constant> = <constant>EM_MENU_SELECT_DELETE</constant></member>
		      <member><constant>undelete</constant> = <constant>EM_MENU_SELECT_UNDELETE</constant></member>
		      <member><constant>mailing_list</constant> = <constant>EM_MENU_SELECT_MAILING_LIST</constant></member>
		      <member><constant>resend</constant> = <constant>EM_MENU_SELECT_EDIT</constant></member>
		      <member><constant>mark_important</constant> = <constant>EM_MENU_SELECT_MARK_IMPORTANT</constant></member>
		      <member><constant>mark_unimportant</constant> = <constant>EM_MENU_SELECT_MARK_UNIMPORTANT</constant></member>
		      <member><constant>flag_followup</constant> = <constant>EM_MENU_SELECT_FLAG_FOLLOWUP</constant></member>
		      <member><constant>flag_completed</constant> = <constant>EM_MENU_SELECT_FLAG_COMPLETED</constant></member>
		      <member><constant>flag_clear</constant> = <constant>EM_MENU_SELECT_FLAG_CLEAR</constant></member>
		      <member><constant>add_sender</constant> = <constant>EM_MENU_SELECT_ADD_SENDER</constant></member>
		      <member><constant>mark_junk</constant> = <constant>EM_MENU_SELECT_MARK_JUNK</constant></member>
		      <member><constant>mark_nojunk</constant> = <constant>EM_MENU_SELECT_MARK_NOJUNK</constant></member>
		      <member><constant>folder</constant> = <constant>EM_MENU_SELECT_FOLDER</constant></member>
		    </simplelist>
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	  <para>
	    This is the main mail view embedded in the &Evolution; Shell.
	  </para>
	</sect2>

	<sect2>
	  <title>Standalone Message View Menu</title>
	  <informaltable>
	    <tgroup cols="2">
	      <tbody valign="top">
		<row>
		  <entry>Name</entry>
		  <entry><interfacename>com.novell.evolution.mail.messagebrowser</interfacename></entry>
		</row>
		<row>
		  <entry>Target</entry>
		  <entry>
		    <link
		      linkend="API-struct--EMMenuTargeSelect">EMMenuTargetSelect</link>, plugin target is &quot;<constant>select</constant>&quot;.
		  </entry>
		</row>
		<row>
		  <entry>Qualifiers</entry>
		  <entry>
		    See the previous section.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	  <para>
	    This is the popup mail-message view.
	  </para>
	</sect2>

	<sect2>
	  <title>Composer Menu</title>
	  <informaltable>
	    <tgroup cols="2">
	      <tbody valign="top">
		<row>
		  <entry>Name</entry>
		  <entry><interfacename>com.novell.evolution.mail.composer</interfacename></entry>
		</row>
		<row>
		  <entry>Target</entry>
		  <entry>Undefined</entry>
		</row>
		<row>
		  <entry>Qualifiers</entry>
		  <entry>Undefined</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	  <para>
	    This is the mail message composer.  This is currently not implemented.
	  </para>
	</sect2>
      </sect1>

      <sect1 id="mail-hooks-config">
	<title>Config Windows and Druids</title>

	  <para>
	    The mail config class is
	    <interfacename>com.novell.evolution.mail.config:1.0</interfacename>.
	  </para>

	<sect2>
	  <title>Account Editor Druid</title>
	  <informaltable>
	    <tgroup cols="2">
	      <tbody valign="top">
		<row>
		  <entry>Name</entry>
		  <entry><interfacename>com.novell.evolution.mail.config.accountDruid</interfacename></entry>
		</row>
		<row>
		  <entry>Target</entry>
		  <entry>
		    <link
		      linkend="API-struct--EMConfigTargetAccount">EMConfigTargetAccount</link>, plugin target is &quot;<constant>account</constant>&quot;.
		  </entry>
		</row>
		<row>
		  <entry>Items</entry>
		  <entry>Define some of the items available and where they fit
		    in the gui</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	  <para>
	    This is the GnomeDruid which is shown when you create a new mail account.
	  </para>
	</sect2>

	<sect2>
	  <title>Account Editor Window</title>
	  <informaltable>
	    <tgroup cols="2">
	      <tbody valign="top">
		<row>
		  <entry>Name</entry>
		  <entry><interfacename>com.novell.evolution.mail.config.accountEditor</interfacename></entry>
		</row>
		<row>
		  <entry>Target</entry>
		  <entry>
		    <link
		      linkend="API-struct--EMConfigTargetAccount">EMConfigTargetAccount</link>, plugin target is &quot;<constant>account</constant>&quot;.
		  </entry>
		</row>
		<row>
		  <entry>Items</entry>
		  <entry>Define some of the items available and where they fit
		    in the gui</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	  <para>
	    This is the editor notebook which is shown when you edit an
	    existing mail account.
	  </para>
	</sect2>

	<sect2>
	  <title>Composer Preferences</title>
	  <informaltable>
	    <tgroup cols="2">
	      <tbody valign="top">
		<row>
		  <entry>Name</entry>
		  <entry><interfacename>com.novell.evolution.mail.composerPrefs</interfacename></entry>
		</row>
		<row>
		  <entry>Target</entry>
		  <entry>
		    <link
		      linkend="API-struct--EMConfigTargetPrefs">EMConfigTargetPrefs</link>, plugin target is &quot;<constant>prefs</constant>&quot;.
		  </entry>
		</row>
		<row>
		  <entry>Items</entry>
		  <entry>Define some of the items available and where they fit
		    in the gui</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	  <para>
	    This is the notebook of configuration items for the composer which
	    are accessed via the main settings window under the Composer tab.
	  </para>
	</sect2>

	<sect2>
	  <title>Mail Preferences</title>
	  <informaltable>
	    <tgroup cols="2">
	      <tbody valign="top">
		<row>
		  <entry>Name</entry>
		  <entry><interfacename>com.novell.evolution.mail.prefs</interfacename></entry>
		</row>
		<row>
		  <entry>Target</entry>
		  <entry>
		    <link
		      linkend="API-struct--EMConfigTargetPrefs">EMConfigTargetPrefs</link>, plugin target is &quot;<constant>prefs</constant>&quot;.
		  </entry>
		</row>
		<row>
		  <entry>Items</entry>
		  <entry>Define some of the items available and where they fit
		    in the gui</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	  <para>
	    This is the notebook of configuration items for the mailer which
	    are accessed via the main settings window under the Mail Settings tab.
	  </para>
	</sect2>

	<sect2>
	  <title>Folder Properties</title>
	  <informaltable>
	    <tgroup cols="2">
	      <tbody valign="top">
		<row>
		  <entry>Name</entry>
		  <entry><interfacename>com.novell.evolution.mail.folderConfig</interfacename></entry>
		</row>
		<row>
		  <entry>Target</entry>
		  <entry>
		    <link
		      linkend="API-struct--EMConfigTargetFolder">EMConfigTargetFolder</link>, plugin target is &quot;<constant>folder</constant>&quot;.
		  </entry>
		</row>
		<row>
		  <entry>Items</entry>
		  <entry>Define some of the items available and where they fit
		    in the gui</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	  <para>
	    This is the notebook of configuration items for a given mail folder
	    which is accessed via the Folder Properties item in the main menu item or
	    folder-tree context menu.
	  </para>
	</sect2>
      </sect1>

      <sect1 id="mail-hooks-event">
	<title>Events</title>

	  <para>
	    The mail event class is
	    <interfacename>com.ximian.evolution.mail.events:1.0</interfacename>.
	  </para>

	<sect2>
	  <title>Folder Changed Event</title>
	  <informaltable>
	    <tgroup cols="2">
	      <tbody valign="top">
		<row>
		  <entry>Name</entry>
		  <entry><constant>folder.changed</constant></entry>
		</row>
		<row>
		  <entry>Target</entry>
		  <entry>
		    <link
		      linkend="API-struct--EMEventTargetFolder">EMEventTargetFolder</link>, plugin target is &quot;<constant>folder</constant>&quot;.
		  </entry>
		</row>
		<row>
		  <entry>Qualifiers</entry>
		  <entry>List qualifiers</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	</sect2>

      </sect1>

      <sect1 id="mail-hooks-format">
	<title>Formatters</title>

	  <para>
	    The mail formatter hook class is
	    <interfacename>com.novell.evolution.mail.format:1.0</interfacename>.
	  </para>

	<sect2>
	  <title>Base Formatter</title>
	  <informaltable>
	    <tgroup cols="2">
	      <tbody valign="top">
		<row>
		  <entry>Name</entry>
		  <entry><constant>EMFormat</constant></entry>
		</row>
		<row>
		  <entry>Target</entry>
		  <entry>
		    <link
		      linkend="API-struct--EMFormatHookTarget">EMFormatHookTarget</link>, plugin target is implied.
		  </entry>
		</row>
		<row>
		  <entry>Qualifiers</entry>
		  <entry>List qualifiers?</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>

	  <para>
	    The EMFormat class is the base class for all formatting types.
	    It should only be used to define compound and complex types which
	    do not rely on outputting any textual information, or rely on any
	    screen or print output differences.
	  </para>
	</sect2>

	<sect2>
	  <title>HTML Formatter</title>
	  <informaltable>
	    <tgroup cols="2">
	      <tbody valign="top">
		<row>
		  <entry>Name</entry>
		  <entry><constant>EMFormatHTML</constant></entry>
		</row>
		<row>
		  <entry>Target</entry>
		  <entry>
		    <link
		      linkend="API-struct--EMFormatHookTarget">EMFormatHookTarget</link>, plugin target is implied.
		  </entry>
		</row>
		<row>
		  <entry>Qualifiers</entry>
		  <entry>List qualifiers?</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>

	  <para>
	    The EMFormatHTML class is the base class for most formatting types
	    which generate HTML output.  It renders output to a GtkHTML
	    object.  It uses a fairly complex multi-thread approach to the
	    formatting to ensure the user-interface is not blocked for
	    processing.  GtkHTML is used in a limited way by this class for
	    HTML parsing and resolution of embedded objects.  Embedded objects
	    and Widgets may not be used from formatters which hook onto this
	    entry point.
	  </para>
	  <para>
	    <emphasis>This section needs a huge amount of
	      explanation, and/or more detail needs to be added to another
	      section about the formatter class</emphasis>
	  </para>
	</sect2>

	<sect2>
	  <title>HTML Display Formatter</title>
	  <informaltable>
	    <tgroup cols="2">
	      <tbody valign="top">
		<row>
		  <entry>Name</entry>
		  <entry><constant>EMFormatHTMLDisplay</constant></entry>
		</row>
		<row>
		  <entry>Target</entry>
		  <entry>
		    <link
		      linkend="API-struct--EMFormatHookTarget">EMFormatHookTarget</link>, plugin target is implied.
		  </entry>
		</row>
		<row>
		  <entry>Qualifiers</entry>
		  <entry>List qualifiers?</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>

	  <para>
	    The EMFormatHTMLDisplay class is a subclass of EMFormatHTML, and is
	    used as a mail display widget.  As such, it has access to all of
	    the facilities of GtkHTML, such as embedded widgets.  Like the
	    EMFormatHTML class, this uses a complex multi-thread architecture.
	  </para>
	  <para>
	    <emphasis>This section needs a huge amount of
	      explanation, and/or more detail needs to be added to another
	      section about the formatter class</emphasis>
	  </para>
	</sect2>

	<sect2>
	  <title>HTML Print Formatter</title>
	  <informaltable>
	    <tgroup cols="2">
	      <tbody valign="top">
		<row>
		  <entry>Name</entry>
		  <entry><constant>EMFormatHTMLPrint</constant></entry>
		</row>
		<row>
		  <entry>Target</entry>
		  <entry>
		    <link
		      linkend="API-struct--EMFormatHookTarget">EMFormatHookTarget</link>, plugin target is implied.
		  </entry>
		</row>
		<row>
		  <entry>Qualifiers</entry>
		  <entry>List qualifiers?</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>

	  <para>
	    The EMFormatHTMLPrint class is a subclass of EMFormatHTML, and is
	    used as a mail printing widget.  It cannot access embedded
	    widgets.  For most purposes you would normally only connect to the
	    EMFormatHTML hook, and generate generic HTML output which could be
	    printed or shown on-screen if it isn't overriden by the display
	    formatter.
	  </para>
	  <para>
	    <emphasis>This section needs a huge amount of
	      explanation, and/or more detail needs to be added to another
	      section about the formatter class</emphasis>
	  </para>
	</sect2>

	<sect2>
	  <title>Mail Quote Formatter</title>
	  <informaltable>
	    <tgroup cols="2">
	      <tbody valign="top">
		<row>
		  <entry>Name</entry>
		  <entry><constant>EMFormatQuote</constant></entry>
		</row>
		<row>
		  <entry>Target</entry>
		  <entry>
		    <link
		      linkend="API-struct--EMFormatHookTarget">EMFormatHookTarget</link>, plugin target is implied.
		  </entry>
		</row>
		<row>
		  <entry>Qualifiers</entry>
		  <entry>List qualifiers?</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>

	  <para>
	    The EMFormatQuote class is a subclass of EMFormat, and is
	    used as generator for quoted mail content and for
	    inline-forwarding.  This formatter converts message objects into
	    a pure HTML stream, which is not parsed directly, but normally fed
	    to the message composer.
	  </para>
	</sect2>

      </sect1>

    </chapter>

    <chapter id="contacts-hooks">
      <title>
	Contacts Hooks
      </title>
      <para>
	None defined.
      </para>
    </chapter>

    <chapter id="calendar-hooks">
      <title>
	Calendar and Tasks Hooks
      </title>
      <para>
	None defined.
      </para>
    </chapter>

    <chapter id="shell-hooks">
      <title>
	Shell Hooks
      </title>
      <para>
	None defined.
      </para>
    </chapter>

  </part>

  <part id="reference">
    <title>
      Reference
    </title>
    <partintro>
      <para>
	This section of the book is a detailed API reference of the
	objects and methods that implement the core plugin system and hooks.
      </para>
      <para>
	It contains the detailed information required for all uses of the
	plugin system. That is, implementors
	of new hook types, application developers providing hook points, and
	plugin developers.
      </para>
    </partintro>
    <chapter id="REF-EPlugin">
      <title>
	EPlugin
      </title>
      <para>
	The EPlugin object manages the loading and invocation of physical
	plugin definitions and plugin binaries.  The base EPlugin class is an
	abstract class which loads plugin definitons, resolving hooks, and
	provides an api for invoking callbacks.
      </para>
      <para>
	The EPluginLib object is a concrete derived class of EPlugin which
	handles loading shared libraries using the GModule interface.
      </para>
      &e-plugin-reference;
    </chapter>

    <chapter>
      <title>
	EPopup
      </title>
      <para>
	The EPopup object manages a single popup menu.  It is used to
	application code as a convenience function for building dynamic popup
	menus based on a specific context.
      </para>
      <para>
	The EPopupHook object is loaded by
	the &EPlugin; system, and is used to provide dynamic extension to the
	application context menus.
      </para>
      &e-popup-reference;

      <!-- this looks like bum here, not sure where else to put it though -->
      &em-popup-reference;
    </chapter>

    <chapter>
      <title>
	EMenu
      </title>
      <para>
	The EMenu object manages the menus for a given view or component.  It
	is used by application code to allow the plugin system an entry point
	to current application view.  It may also be used by the application as
	a convenience function to dynamically alter the menu system based on
	user context.
      </para>
      <para>
	The EMenuHook object is loaded by the &EPlugin; system, and is used to
	provide dynamic extension to the application menus.
      </para>
      &e-menu-reference;
    </chapter>

    <chapter>
      <title>
	EConfig
      </title>
      <para>
	The EConfig object manages the building of dynamic configuration pages
	to configure specific application objects.  The same basic object can
	be used to fully drive a wizard-like druid object, or to drive a
	note-book of configuration options.  It is used by application code to
	provide the core controller in a model-view-controller implementation
	of a UI window.
      </para>
      <para>
	The EConfigHook object is loaded by the &EPlugin; system, and is used hook
	in additional configuration items into configuration windows or druids
	dynamically.
      </para>
      &e-config-reference;
    </chapter>

    <chapter>
      <title>
	EEvent
      </title>
      <para>
	The EEvent object manages broadcast of events for a given component or
	application.  It is used by application code to provide the plugin
	system with an entry point for user and system state events.
      </para>
      <para>
	The EEventHook object is loaded by the &EPlugin; system, and is used hook
	event listeners into dynamically loaded event handlers.
      </para>
      &e-event-reference;
    </chapter>
  </part>

</book>
